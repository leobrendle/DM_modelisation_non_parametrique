---
title: "TP Apprentissage statistique : modelisation non-paramétrique par des fonctions
  B-splines"
author: "Fouad AFANE, Emilie GALLAND, Léo BRENDLE"
date: "Décembre 2025"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(mgcv)
```

## Introduction

L'objectif de ce TP est de modéliser le prix des appartements à Varsovie en utilisant des méthodes non paramétriques.

```{r warning=FALSE, message=FALSE}
require(ggplot2)
require(HRW)
require(mgcv)
require(splines)
require(dplyr)
data(WarsawApts)
str(WarsawApts)
```

Les variables du jeu de données sont les suivantes : 

- **surface** : surface en mètres carrés  
- **district** : district (variable facteur à 4 modalités)  
- **n.rooms** : nombre de pièces  
- **floor** : étage  
- **construction.date** : année de construction  
- **areaPerMzloty** : prix au mètre carré (variable à prédire)

## Partie 1 : Prédiction avec une seule variable explicative
### 1. Exploration des variables

Pour commencer, on veut modéliser le prix des appartements en fonction d'une seule variable. Pour choisir la plus adaptée, traçons le prix des appartements en fonction des différentes variables. On considère que l'on dispose de 4 variables explicatives quantitatives et une variable qualitative (district), que l'on va écarter de l'étude pour le moment.

```{r, message=FALSE}
library(ggplot2)
library(patchwork)

p1 <- ggplot(WarsawApts, aes(x = surface, y = areaPerMzloty)) +
  geom_point(color = "red") +
  labs(title = "Prix en fonction de surface",
       x = "Surface (m²)", y = "Prix au m²")

p2 <- ggplot(WarsawApts, aes(x = n.rooms, y = areaPerMzloty)) +
  geom_point(color = "blue") +
  labs(title = "Prix en fonction du nb de chambres",
       x = "Nombre de chambres", y = "Prix au m²")

p3 <- ggplot(WarsawApts, aes(x = floor, y = areaPerMzloty)) +
  geom_point(color = "darkgreen") +
  labs(title = "Prix en fonction de l'étage",
       x = "Étage", y = "Prix au m²")

p4 <- ggplot(WarsawApts, aes(x = construction.date, y = areaPerMzloty)) +
  geom_point(color = "purple") +
  labs(title = "Prix en fonction de l'année de construction",
       x = "Année de construction", y = "Prix au m²")

(p1 | p2) /
(p3 | p4)
```


### 2. Choix d’une variable explicative pour la modélisation univariée

Les graphiques précédents (P1–P4) représentent le prix au m² en fonction de la surface, de l’étage et de l’année de construction. Visuellement, aucune de ces relations ne semble strictement linéaire, en particulier pour `construction.date` où l’on observe une forme en « bosse » : les immeubles d’une période intermédiaire paraissent plus chers que les constructions très anciennes ou très récentes.

Afin de choisir une variable explicative unique pour la suite, nous avons comparé, pour chacune des variables quantitatives `surface`, `floor` et `construction.date`, trois modèles paramétriques : un modèle linéaire simple, un polynôme d’ordre 2 et un polynôme d’ordre 3 de `areaPerMzloty` en fonction de cette variable. Pour chaque combinaison, nous avons relevé le coefficient de détermination R² et le critère d’information AIC, présentés dans le tableau ci-dessous.

```{r choix_var_univ, echo=TRUE, message=FALSE, warning=FALSE}

donnees <- WarsawApts
vars <- c("surface", "floor", "construction.date")

res <- data.frame(
  var       = vars,
  R2_lin    = NA,
  R2_poly2  = NA,
  R2_poly3  = NA,
  AIC_lin   = NA,
  AIC_poly2 = NA,
  AIC_poly3 = NA
)

for (j in seq_along(vars)) {
  xname <- vars[j]
  x     <- donnees[[xname]]
  
  # Modèle linéaire simple
  m_lin <- lm(donnees$areaPerMzloty ~ x)
  
  # Polynôme ordre 2
  m_poly2 <- lm(donnees$areaPerMzloty ~ poly(x, 2))
  
  # Polynôme ordre 3
  m_poly3 <- lm(donnees$areaPerMzloty ~ poly(x, 3))
  
  res$R2_lin[j]    <- summary(m_lin)$r.squared
  res$R2_poly2[j]  <- summary(m_poly2)$r.squared
  res$R2_poly3[j]  <- summary(m_poly3)$r.squared
  
  res$AIC_lin[j]   <- AIC(m_lin)
  res$AIC_poly2[j] <- AIC(m_poly2)
  res$AIC_poly3[j] <- AIC(m_poly3)
}

res

```


Les résultats montrent que, pour `surface` et `floor`, même un polynôme cubique n’explique qu’une faible part de la variabilité du prix au m² (R² inférieur à 0,10) et conduit à des AIC relativement élevés (autour de 3 660–3 690). En revanche, pour `construction.date`, le polynôme d’ordre 3 atteint un R² proche de 0,30 et un AIC nettement plus faible (environ 3 558), ce qui en fait de loin le meilleur modèle paramétrique parmi ceux testés.

Nous retenons donc **l’année de construction (`construction.date`)** comme variable explicative unique pour la première étape de la modélisation. Dans la suite, nous comparerons ce modèle paramétrique cubique à un modèle non paramétrique à base de splines, mieux adapté à la forme non linéaire observée entre l’année de construction et le prix au m².


### 2. Modélisation paramétrique du prix en fonction de la date de construction
```{r}

m_year_poly2 <- lm(areaPerMzloty ~ poly(construction.date, 2), data = donnees)
m_year_poly3 <- lm(areaPerMzloty ~ poly(construction.date, 3), data = donnees)

newdat <- data.frame(
  construction.date = seq(min(donnees$construction.date),
                          max(donnees$construction.date),
                          length.out = 200)
)
newdat$pred2 <- predict(m_year_poly2, newdat)
newdat$pred3 <- predict(m_year_poly3, newdat)

newdat_long <- rbind(
  data.frame(
    construction.date = newdat$construction.date,
    prediction        = newdat$pred2,
    modele            = "Polynôme degré 2"
  ),
  data.frame(
    construction.date = newdat$construction.date,
    prediction        = newdat$pred3,
    modele            = "Polynôme degré 3"
  )
)

ggplot(donnees, aes(x = construction.date, y = areaPerMzloty)) +
  geom_point(alpha = 0.5, size = 1) +
  geom_line(data = newdat_long,
            aes(y = prediction, colour = modele),
            linewidth = 1.1) +
  scale_colour_manual(values = c("Polynôme degré 2" = "blue",
                                 "Polynôme degré 3" = "red")) +
  labs(
    x = "Année de construction",
    y = "Prix au m²",
    title = "Prix au m² ~ année : polynômes d'ordre 2 et 3",
    colour = ""
  ) +
  theme_bw()


```

La figure ci-dessus représente le prix au m² en fonction de l’année de construction, ainsi que les courbes ajustées par un polynôme d’ordre 2 et un polynôme d’ordre 3. Le modèle quadratique reproduit grossièrement la forme en cloche observée dans les données, mais reste assez rigide : la bosse centrale est sous-estimée et la baisse pour les immeubles récents n’est pas parfaitement capturée.

Le polynôme d’ordre 3 offre une meilleure flexibilité. La courbe rouge suit plus fidèlement la hausse des prix au m² pour les immeubles construits autour de la période intermédiaire, puis la baisse pour les constructions les plus récentes. Cela se traduit par un R² plus élevé (environ 0,30 contre 0,24 pour l’ordre 2) et un AIC plus faible. Ce modèle cubique constitue donc notre **meilleur modèle paramétrique univarié** pour l’effet de l’année de construction.

Cependant, il reste un modèle **global** : une seule fonction cubique doit décrire l’ensemble de la période 1930–2008, ce qui limite la capacité à s’adapter **localement** aux différentes époques. Cette limitation motive l’introduction, dans la section suivante, d’un modèle non paramétrique à base de splines pénalisées.

### 3. Modélisation non paramétrique du prix en fonction de l'année

Nous allons dans cette partie construire un modèle B-spline pénalisée en utilisant la variable
annee.construction.

On commence par normaliser cette variable :

```{r}
annee <- WarsawApts$construction.date
WarsawApts$construction.date <- (annee-min(annee))/(max(annee)-min(annee)) 

WarsawApts <- WarsawApts %>%
  arrange(construction.date)
```

Ensuite on définit les modèles GAM avec le paramètre de lissage sp = $\lambda $ que l'on cherche par validation croisée par blocs.

```{r}
B <- 5
set.seed(783)
df <- WarsawApts[sample(nrow(WarsawApts)),]

n <- nrow(df) 
block_size <- floor(n / B)

grid <- 10^seq(1, -2, length = 100)
vec_mse <- numeric(length(grid))

for (i in 1:length(grid)) {

  lambda <- grid[i]
  mse_blocks <- numeric(B)

  for (b in 1:B) {
    test_idx <- ((b - 1) * block_size + 1) : (b * block_size)
    if (b == B){
      test_idx <- ((b - 1) * block_size + 1) : n
    } 
    train_data <- df[-test_idx, ] %>%
      arrange(construction.date)
    test_data  <- df[test_idx, ]%>%
      arrange(construction.date)

    res.fit <- gam(areaPerMzloty ~ s(construction.date, bs = "bs", k = 5, m = c(2, 2)),
      data = train_data, sp = lambda)
    
    pred <- predict(res.fit, newdata = test_data)
    mse_blocks[b] <- mean((test_data$areaPerMzloty - pred)^2)
  }
  vec_mse[i] <- mean(mse_blocks)
}

# plot validation croisée

mse_grid <- data.frame(grid, vec_mse )
ggplot(data = mse_grid, aes(log(grid), vec_mse))+
  geom_point()+
  geom_vline(xintercept = log(grid[which.min(vec_mse)]), col = "red")+
  ggtitle("Validation croisée B-splines")+
  theme_bw()

lambda_cv <- grid[which.min(vec_mse)] 
lambda_cv
```

On choisit alors le lambda qui minimise le mse, c'est à dire \lambda = 3.05 . 
On obtient alors le modèle suivant :

```{r}
attach(WarsawApts)
best.fit <- gam(areaPerMzloty ~ s(construction.date, bs = "bs", k = 5, m = c(2, 2)), data = WarsawApts, sp = lambda_cv)
annee <- construction.date*(max(annee)-min(annee))+min(annee) #reconversion de la variable

ggplot(data = data2, aes(x = annee, y = areaPerMzloty)) +
  geom_point() +  
  geom_line(aes(y = predict(best.fit), color = "B-spline pénalisée")) +  
  theme_bw() + 
  ggtitle("Prix au m² en fonction de l'année") +
  scale_color_manual(values = c("B-spline pénalisée" = "red"))  
```
On peut alors remarquer que le modèle semble bien s'adapter aux données sans trop coller aux données, ce qui permet de limiter le surapprentissage.


## Partie 2 : Amélioration du modèle non paramétrique en utilisant plusieurs variables explicatives

Dans la Partie 1, nous avons étudié en détail la relation entre le prix au m² et une seule variable explicative, et nous avons constaté que l’année de construction présentait la relation la plus structurée. Cependant, il est raisonnable de penser que le prix d’un appartement ne dépend pas seulement d’une variable mais de plusieurs caractéristiques en même temps.
Dans cette deuxième partie, nous cherchons donc à améliorer la qualité prédictive du modèle en intégrant simultanément l’ensemble des variables quantitatives.
Nous étudions successivement :
-un modèle linéaire multiple,
-un modèle polynomial,
-un modèle GAM multivarié,
puis nous comparons ces modèles à l’aide du critère AIC.

### 1. Modèle linéaire linéaire multiple

Nous commençons par ajuster un modèle linéaire classique incluant toutes les variables explicatives quantitatives :
$$
\text{areaPerMzloty} = 
\beta_0 + 
\beta_1 \, \text{surface} + 
\beta_2 \, \text{n.rooms} + 
\beta_3 \, \text{floor} + 
\beta_4 \, \text{construction.date} + 
\varepsilon
$$

```{r}

m_lm <- lm(areaPerMzloty ~ surface + n.rooms + floor + construction.date,
data = WarsawApts)

summary(m_lm)
AIC(m_lm)

```

Ce modèle sert d’étalon pour comparer les gains des méthodes non-paramétriques. On obtient un AIC de 3649. Le $R^2$ ajusté vaut 0.12, ce qui n'est pas très satisfaisant. Le modèle parvient à expliquer une partie de la variabilité des prix, mais il lui manque de la flexibilité pour capturer les effets non linéaires mis en évidence en Partie 1.

### 2. Modèle polynomial

Pour introduire davantage de flexibilité sans tomber dans un modèle entièrement non paramétrique, nous ajoutons un terme quadratique pour chaque variable explicative. Le modèle devient :
$$\text{areaPerMzloty} = 
\beta_0 + 
\beta_{11} \, \text{surface} + 
\beta_{12} \, \text{surface}^2 + 
\beta_{21} \, \text{n.rooms} + 
\beta_{22} \, \text{n.rooms}^2 + 
\beta_{31} \, \text{floor} + 
\beta_{32} \, \text{floor}^2 + 
\beta_{41} \, \text{construction.date} + 
\beta_{42} \, \text{construction.date}^2 + 
\varepsilon$$

```{r}
m_poly <- lm(areaPerMzloty ~
poly(surface, 2, raw = TRUE) +
poly(n.rooms, 2, raw = TRUE) +
poly(floor, 2, raw = TRUE) +
poly(construction.date, 2, raw = TRUE),
data = WarsawApts)

summary(m_poly)
AIC(m_poly)

```
Dans ce modèle, le $R^2$ ajusté est meilleur (0.26): le modèle capture plus de structure. En contrepartie, l’interprétation devient difficile et le nombre de paramètres augmente rapidement. L'AIC est plus faible (3581) donc la complexité supplémentaire du modèle est justifiée.

Comparons à présent les modèles linéaires et polynomiaux, qui sont imbriqués, via ANOVA.
```{r}
anova(m_lm, m_poly)

```


### 3. GAM avec splines

Nous passons maintenant à un modèle non paramétrique multivarié de type GAM.
Chaque variable explicative est représentée par une spline pénalisée :
$$
\text{areaPerMzloty} = 
s_1(\text{surface}) + 
s_2(\text{n.rooms}) + 
s_3(\text{floor}) + 
s_4(\text{construction.date}) + 
\varepsilon$$

```{r}
library(mgcv)

m_gam <- gam(areaPerMzloty ~
s(surface, bs="bs", k=10, m=c(2,2)) +
s(n.rooms, bs="bs", k=6, m=c(2,2)) +
s(floor, bs="bs", k=6, m=c(2,2)) +
s(construction.date, bs="bs", k=10, m=c(2,2)),
data = WarsawApts)

summary(m_gam)
AIC(m_gam)

```

Les edf (effective degrees of freedom) montrent la complexité réellement utilisée par chaque spline. On voit que les edf de n.rooms et floor sont proches de 1, ce qui montre un effet plutôt linéaire (ces variables ne bénéficient pas de la complexité des splines).

On voit que la surface et la date de construction sont les variables les plus significatives (p-valeur < 0.001), et que le nombre de pièces et l'étage ne sont pas significatives.

Le $R^2$ ajusté est bien meilleur : il vaut 0.39. Le critère AIC quand à lui est plus lègèrement plus faible que pour le modèle polynomial, ce qui nous pousse à selectionner les splines par rapport au modèle polynomial.

On peut visualiser l'allure de la spline sur chaque variable :
```{r}
library(ggplot2)
library(mgcv)
library(dplyr)
library(tidyr)

pred_list <- list()
for (i in seq_along(m_gam$smooth)) {
  smooth_i <- m_gam$smooth[[i]]$term
  pred <- predict(m_gam, type = "terms", se.fit = TRUE)
  df <- data.frame(
    x = m_gam$model[[smooth_i]],
    fit = pred$fit[, i],
    se = pred$se.fit[, i],
    residuals = residuals(m_gam)
  )
  df$variable <- smooth_i
  pred_list[[i]] <- df
}

df_all <- bind_rows(pred_list)

ggplot(df_all, aes(x = x, y = fit)) +
  geom_ribbon(aes(ymin = fit - 2*se, ymax = fit + 2*se), fill = "lightblue", alpha = 0.4) +
  geom_line(color = "blue") +
  geom_point(aes(y = residuals), size = 0.8, alpha = 0.5) +
  facet_wrap(~variable, scales = "free_x") +
  theme_minimal()


```

### 4. Comparaison des modèles par le critère AIC

Récapitulons les scores AIC obtenus : 

```{r}
AIC(m_lm, m_poly, m_gam)

```

Le modèle linéaire est le plus simple mais ne capture pas les effets non linéaires.
Le modèle polynomial représente une amélioration, mais sa flexibilité augmente le nombre de paramètres.
Le modèle GAM offre le meilleur compromis : entre complexité et flexibilité.

Visualisons à présent les prédictions des différents modèles.




## Partie 3 : Intégration de la variable qualitative

Dans les parties précédentes, nous avons travaillé uniquement avec des variables explicatives quantitatives.  
Le jeu de données contient cependant une variable qualitative importante : 'district', qui indique le district de Varsovie dans lequel se trouve l’appartement.  
Dans cette partie, on cherche à voir si le niveau de prix et la forme de la relation avec l’année de construction peuvent différer selon le district.

On commence par un modèle linéaire de type ANCOVA, puis on utilise des modèles GAM qui autorisent une relation non linéaire entre 'construction.date' et 'areaPerMzloty', d’abord commune à tous les districts, puis spécifique à chaque district.

### 1. Modèle linéaire avec district (référence paramétrique)

On considère d’abord un modèle linéaire additif où l’on combine la variable qualitative 'district' et la variable quantitative 'construction.date' :

$$
\text{areaPerMzloty} = 
\beta_0 +
\beta_{\text{district}} +
\beta_1 \, \text{construction.date} +
\varepsilon.
$$

Ce modèle permet de capter un effet de niveau différent selon le district (via les coefficients associés aux modalités de 'district'), tout en gardant une pente commune pour l’année de construction.

```{r}
m_lin_qual <- gam(areaPerMzloty ~ district + construction.date,
data = WarsawApts)

summary(m_lin_qual)

```

Dans ce premier modèle, on combine la variable qualitative `district` et la variable quantitative `construction.date` de façon linéaire.

La référence pour `district` est le district de base (ici celui qui n’apparaît pas explicitement dans le tableau des coefficients). L’intercept (~121.8) correspond donc à la valeur moyenne de `areaPerMzloty` dans ce district de référence, pour une valeur moyenne de `construction.date`.

Le coefficient de `construction.date` est négatif (-14.2) et significatif. Cela suggère qu’avec ce modèle linéaire, les appartements construits plus récemment ont en moyenne un prix au m² légèrement plus faible, une fois le district fixé. Cet effet reste cependant modeste et il est imposé comme strictement linéaire.

Pour les districts, seul `districtSrodmiescie` apparaît significativement différent du district de référence, avec un effet d’environ -15 points sur `areaPerMzloty` (à année de construction donnée). Les coefficients associés à `districtWola` et `districtZoliborz` ne sont pas significatifs au seuil habituel.

Enfin, la part de variance expliquée par le modèle reste faible (R² ajusté ≈ 0.12). Ce modèle linéaire capture donc une partie de la structure, mais il laisse une grande variabilité inexpliquée. Cela justifie d’essayer des modèles plus flexibles, en particulier un modèle GAM avec un effet lissé de `construction.date`.


### 2. Modèle GAM avec effet lissé commun de l’année de construction

Le modèle précédent suppose que l’effet de l’année de construction est linéaire.  
On remplace maintenant ce terme linéaire par une spline pénalisée, tout en conservant un effet de niveau par district :

$$
\text{areaPerMzloty} = 
\beta_0 +
\beta_{\text{district}} +
f(\text{construction.date}) +
\varepsilon,
$$

où \(f\) est une fonction lisse estimée par B-splines pénalisées.

```{r}
m_gam_commune <- gam(
areaPerMzloty ~ district +
s(construction.date, bs = "bs", k = 5, m = c(2, 2)),
data = WarsawApts
)

summary(m_gam_commune)

plot(m_gam_commune, shade = TRUE, seWithMean = TRUE, scale = 0)

```

On observe une relation clairement non linéaire : l’effet augmente jusqu’aux constructions de la fin des années 1970, puis diminue das les années 2000. Cet effet est estimé conditionnellement au district, et centré (valeur moyenne proche de zéro).






### 3. Modèle GAM avec courbes spécifiques par district

Enfin, on autorise l’effet de l’année de construction à varier selon le district.  
On obtient alors un modèle où chaque district possède sa propre fonction lissée :

$$
\text{areaPerMzloty} = 
\beta_0 +
\beta_{\text{district}} +
f_{\text{district}}(\text{construction.date}) +
\varepsilon,
$$

```{r}
library(mgcv)

WarsawApts$district <- factor(WarsawApts$district)
levels_d <- levels(WarsawApts$district)

m_gam_par_district <- gam(
  areaPerMzloty ~ district +
    s(construction.date, by = district,
      bs = "bs", k = 5, m = c(2, 2)),
  data = WarsawApts
)

summary(m_gam_par_district)

par(mfrow = c(2, 2),
    mar = c(4, 5, 3, 1))  # un peu de marge en haut pour le titre

# Colonne de gauche : ylab, colonne de droite : ylab vide pour pas coller

plot(m_gam_par_district, select = 1,
     seWithMean = TRUE, rug = FALSE,
     xlab = "année de construction (centrée/réduite)",
     ylab = "effet sur areaPerMzloty",
     main = paste("District :", levels_d[1]))

plot(m_gam_par_district, select = 2,
     seWithMean = TRUE, rug = FALSE,
     xlab = "année de construction (centrée/réduite)",
     ylab = "",
     main = paste("District :", levels_d[2]))

plot(m_gam_par_district, select = 3,
     seWithMean = TRUE, rug = FALSE,
     xlab = "année de construction (centrée/réduite)",
     ylab = "effet sur areaPerMzloty",
     main = paste("District :", levels_d[3]))

plot(m_gam_par_district, select = 4,
     seWithMean = TRUE, rug = FALSE,
     xlab = "année de construction (centrée/réduite)",
     ylab = "",
     main = paste("District :", levels_d[4]))

```

Les courbes estimées montrent que l’effet de l’année de construction sur areaPerMzloty varie nettement selon le district. 
**À Mokotow**, la relation est clairement non linéaire, avec un maximum autour des constructions des années 1970–1980, suggérant une valorisation particulière de cette période. À Srodmiescie, l’effet est plus stable et de faible amplitude, indiquant un marché plus homogène où l’âge du bâtiment joue un rôle limité. À Wola, la courbe est presque plate et les intervalles de confiance larges, ce qui traduit une influence très faible de l’année de construction sur le prix. Enfin, à Zoliborz, la relation est fortement non linéaire, avec un pic marqué suivi d’une baisse, révélant une forte hétérogénéité selon les générations d’immeubles. Ces différences justifient l’utilisation d’un modèle non paramétrique où la forme de la fonction peut varier par district.

### 4. Comparaison des modèles

Pour résumer, on compare les trois modèles :

- Modèle linéaire avec district ('m_lin_qual') ;
- Modèle GAM avec courbe commune pour l’année de construction ('m_gam_commune') ;
- Modèle GAM avec courbes spécifiques par district ('m_gam_par_district').

On utilise le critère AIC et des tests F (modèles emboîtés) comme dans le TP 2 pour décider si la flexibilité supplémentaire est justifiée.

```{r}
AIC(m_lin_qual, m_gam_commune, m_gam_par_district)

anova(m_lin_qual, m_gam_commune, test = "F")
anova(m_gam_commune, m_gam_par_district, test = "F")

```
La comparaison montre d’abord que la spline commune améliore très nettement le modèle par rapport à la relation linéaire (p < 2.2e−16), ce qui confirme le caractère non linéaire de l’effet de l’année de construction. La comparaison suivante indique qu’autoriser une spline différente selon le district améliore également l’ajustement, mais de manière plus limitée (p ≈ 0.073). Ainsi, la non-linéarité est clairement établie, et une variation de la forme par district est plausible, même si l’évidence statistique reste marginale.


## Conclusion


