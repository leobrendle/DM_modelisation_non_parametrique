---
title: "TP Apprentissage statistique : modelisation non-paramétrique par des fonctions B-splines"
author: "Fouad AFANE, Emilie GALLAND, Léo BRENDLE"
date: "Décembre 2025"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

L'objectif de ce TP est de modéliser le prix des appartements à Varsovie en utilisant des méthodes non paramétriques.

```{r warning=FALSE, message=FALSE}
require(ggplot2)
require(HRW)
require(mgcv)
require(splines)
require(dplyr)
data(WarsawApts)
str(WarsawApts)
```

Les variables du jeu de données sont les suivantes : 

- **surface** : surface en mètres carrés  
- **district** : district (variable facteur à 4 modalités)  
- **n.rooms** : nombre de pièces  
- **floor** : étage  
- **construction.date** : année de construction  
- **areaPerMzloty** : prix au mètre carré (variable à prédire)

## Partie 1 : Prédiction avec une seule variable explicative
### 1. Exploration des variables

Pour commencer, on veut modéliser le prix des appartements en fonction d'une seule variable. Pour choisir la plus adaptée, traçons le prix des appartements en fonction des différentes variables. On considère que l'on dispose de 4 variables explicatives quantitatives et une variable qualitative (district), que l'on va écarter de l'étude pour le moment.

```{r, message=FALSE}
library(ggplot2)
library(patchwork)

p1 <- ggplot(WarsawApts, aes(x = surface, y = areaPerMzloty)) +
  geom_point(color = "red") +
  labs(title = "Prix en fonction de surface",
       x = "Surface (m²)", y = "Prix au m²")

p2 <- ggplot(WarsawApts, aes(x = n.rooms, y = areaPerMzloty)) +
  geom_point(color = "blue") +
  labs(title = "Prix en fonction du nb de chambres",
       x = "Nombre de chambres", y = "Prix au m²")

p3 <- ggplot(WarsawApts, aes(x = floor, y = areaPerMzloty)) +
  geom_point(color = "darkgreen") +
  labs(title = "Prix en fonction de l'étage",
       x = "Étage", y = "Prix au m²")

p4 <- ggplot(WarsawApts, aes(x = construction.date, y = areaPerMzloty)) +
  geom_point(color = "purple") +
  labs(title = "Prix en fonction de l'année de construction",
       x = "Année de construction", y = "Prix au m²")

(p1 | p2) /
(p3 | p4)
```

Il semble que la variable la plus adaptée pour faire une régression de la forme $y = f(x)$ soit l'année de construction. On va commencer pour faire une régression linéaire simple et polynomiale pour montrer qu'une méthode non paramétrique est plus adéptée.

### 2. Modélisation paramétrique du prix en fonction de l'année (Fouad)

### 3. Modélisation non paramétrique du prix en fonction de l'année (Emilie)

On commence par normaliser la variable année :

```{r}
annee <- WarsawApts$construction.date
WarsawApts$construction.date <- (annee-min(annee))/(max(annee)-min(annee)) 

WarsawApts <- WarsawApts %>%
  arrange(construction.date)
```

Ensuite on définit les modèles GAM avec la paramètre de lissage sp = \lambda que l'on 
cherche par validation croisée par blocs.

```{r}
B <- 5
df <- WarsawApts[sample(nrow(WarsawApts)),]

n <- nrow(df) 
block_size <- floor(n / B)

grid <- 10^seq(2, -2, length = 100)
vec_mse <- numeric(length(grid))

for (i in 1:length(grid)) {

  lambda <- grid[i]
  mse_blocks <- numeric(B)

  for (b in 1:B) {
    test_idx <- ((b - 1) * block_size + 1) : (b * block_size)
    if (b == B){
      test_idx <- ((b - 1) * block_size + 1) : n
    } 
    train_data <- df[-test_idx, ] %>%
      arrange(construction.date)
    test_data  <- df[test_idx, ]%>%
      arrange(construction.date)

    res.fit <- gam(areaPerMzloty ~ s(construction.date, bs = "bs", k = 5, m = c(2, 2)),
      data = train_data, sp = lambda)
    
    pred <- predict(res.fit, newdata = test_data)
    mse_blocks[b] <- mean((test_data$areaPerMzloty - pred)^2)
  }
  vec_mse[i] <- mean(mse_blocks)
}

# plot validation croisée

mse_grid <- data.frame(grid, vec_mse )
ggplot(data = mse_grid, aes(log(grid), vec_mse))+
  geom_point()+
  geom_vline(xintercept = log(grid[which.min(vec_mse)]), col = "red")+
  ggtitle("Validation croisée B-splines")+
  theme_bw()

lambda_cv <- grid[which.min(vec_mse)] 
```

On choisit alors le lambda qui minimise le mse. On obtient alors le modèle suivant :

```{r}
attach(WarsawApts)
best.fit <- gam(areaPerMzloty ~ s(construction.date, bs = "bs", k = 5, m = c(2, 2)), data = WarsawApts, sp = lambda_cv)
plot(construction.date, areaPerMzloty)
lines(construction.date, predict(best.fit), type = "l", col = "red")
```

## Partie 2 : Amélioration du modèle non paramétrique en utilisant plusieurs variables explicatives

Dans cette partie, on cherche à améliorer la prédiction du prix au m² en utilisant plusieurs variables explicatives en même temps.
L’idée est de comparer différents types de modèles :
- le modèle linéaire multiple
- le modèle additif généralisé (GAM) avec B-splines
- modèle hybride, où certaines variables sont linéaires et d’autres modélisées par des splines

Nous utiliserons systématiquement la fonction anova() et les critères AIC pour comparer les modèles entre eux.

### 1. Modèle linéaire linéaire multiple

Ce modèle sert d’étalon pour comparer les gains des méthodes non-paramétriques.

### 2. GAM avec splines

### 3. Comparaison des modèles avec ANOVA et par le critère AIC

## Partie 3 : Intégration de la variable qualitative

## Conclusion


